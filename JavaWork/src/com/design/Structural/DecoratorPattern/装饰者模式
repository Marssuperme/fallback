装饰者模式

    --> 允许向一个现有的对象添加新的功能，同时又不改变其结构。它是作为现有的类的一个包装。

    --> 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

    --> 装饰者模式是以对客户端透明的方式扩展对象的功能，是继承关系的一种替代方案！

    --> 角色

        --> 抽象组件(Component)

            --> 声明了在具体组件中实现的业务方法，可以使客户端以一致的方式处理未修饰对象与修饰后的对象，实现了客户端的透明操作。
            --> 可以是接口或抽象类，具体组件与抽象装饰类的共同父类
            --> 例子： Dinner

        --> 具体组件(ConcreteComponent)

            --> 实现抽象组件中生命的方法，装饰器类可以给他增加额外的责任(方法)
            --> 例子： Rices

        --> 抽象装饰类(Decorator)

            --> 装饰组件对象的，内部一定要有一个指向组件对象的引用！！！
            --> 通过该引用可以调用装饰前构建对象的方法，并通过其子类扩展该方法，已达到装饰的目的。
            --> 例子： DinnerDecorator

        --> 具体装饰类(ConcreteDecorator)
            --> 抽象装饰类的具体实现，可以调用抽象装饰类中定义的方法，也可以新增新的方法来扩充对象的行为。
            --> 例子： Beef, Chicken

    --> 优缺点

        --> 扩展对象功能，比继承灵活，不会导致类个数急剧增加；
        --> 可以通过一种动态的方式在运行时选择不同的具体装饰类，从而实现不同的行为；
        --> 避免了高层次类有太多的特征，可以从一个最简单的类慢慢给他添加功能；
        --> 会产生很多小装饰者对象，会影响性能，过多使用该模式也会使程序变得复杂。