
原型模式:

    在原型模式中我们可以利用过一个原型对象来指明我们所要创建对象的类型
    然后通过复制这个对象的方法来获得与该对象一模一样的对象实例。
    所谓原型模式就是用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。
	
	--> 用于创建重复的对象, 同时又能保证性能
	--> 这种模式是实现了一个原型接口, 该接口用于创建当前对象的克隆. 当直接创建对象的代价比较大时, 则采用这种模式
	--> 通过给出一个原型对象来指明所有创建的对象的类型, 然后用复制这个原型对象的办法创建出更多同类型的对象
	--> 原型模式是通过拷贝一个现有对象生成新对象的

		--> 浅拷贝实现 Cloneable, 重写
		    --> 浅拷贝：使用一个已知实例对新创建实例的成员变量逐个赋值，这个方式被称为浅拷贝。
		    --> 只新建基本类型数据，不新建引用类型数据

		--> 深拷贝是通过实现 Serializable 读取二进制流
		    --> 深拷贝：当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，
		               还要为引用类型的成员变量创建新的实例，并且初始化为形式参数实例值。

    角色

        --> 抽象原型类(Prototype)
            --> 声明克隆方法的接口，是所有具体原型类的公共父类，它可是抽象类也可以是接口，甚至可以是具体实现类。

        --> 具体原型类(ConcretePrototype)
            --> 它实现抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。

        --> 客户端(Client)
            --> 在客户类中，让一个原型对象克隆自身从而创建一个新的对象。
		
表现形式：

	--> （1）简单形式

	--> （2）登记形式
		--> 作为原型模式的第二种形式, 它多了一个原型管理器角色(PrototypeManager)
		--> 该角色的作用是：创建具体原型类的对象, 并记录每一个被创建的对象

应用场景：

    --> 优化资源
    --> 性能，安全要求
    --> 一个对象多个调用者


    1.执行克隆方法，不会调用构造方法

    2.克隆会生成的新的对象变量，指向的却是同一个内存地址！

    3.克隆前后数据类型一致！

    4.克隆的时候，类中基本数据类型的属性会新建，但是引用类型的只会生成个新的引用变量，引用变量的地址依旧指向同一个内存地址！