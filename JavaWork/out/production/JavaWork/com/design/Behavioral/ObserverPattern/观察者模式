观察者模式

    --> 发布-订阅模式(Publish/Subscribe)
    --> 模型-视图模式(Model/View)
    --> 源-监听器模式(Source/Listener)
    --> 从属者模式(Dependents)

    --> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

    角色

        --> 抽象被观察者(Subject)

            --> 把所有观察者对象的引用保存到集合中，然后提供添加，移除，和通知观察者对象更新的方法。

        --> 被观察者(ConcreteSubject)

            --> 集合存放观察者，重写增删和通知观察者的方法，当发生变化时通知观察者更新。

        --> 抽象观察者(Observer)

            --> 定义一个更新接口，给被观察者更新的时候调

        --> 具体观察者(ConcreteObserver)

            --> 继承抽象观察者，实现具体的更新方法

    推与拉

        --> 推方式

            --> 被观察者对象向观察者推送主题的详细信息
            --> 不管观察者是否需要，推送的信息通常是被观察者对象的全部或部分数据。

        --> 拉方式

            --> 被观察者对象再通知观察者时，只传递少量信息。
            --> 如果观察者需要更详细的信息，可以主动到被观察者中获取，相当于观察者从被观察者中拉取数据。
            --> 套路：把主题对象自身通过update()方法传递给观察者，观察者在需要获取的时候，通过这个引用来获取。

    使用场景：

        --> 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
        --> 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
        --> 一个对象必须通知其他对象，而并不知道这些对象是谁。
        --> 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。

    优点：

        --> 实现了观察者和目标之间的抽象耦合
       -->  实现了动态联动（一个操作会引起其它相关的操作）
       -->  支持广播通信

    缺点

        --> 互为观察者与被观察者间有循环依赖的话，要注意相互通知引起的死循环！
        --> 可能会引起武威操作，误更新。
