外观模式

    --> 隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。
    --> 它向现有的系统添加一个接口，来隐藏系统的复杂性。

    --> 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

    --> 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。


    角色：

        --> 外观角色(Facade)

            --> 客户端可以调用他的方法，在外观角色中可以知道相关子系统的功能和责任；
            --> 在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。

        --> 子系统角色(Subsystem)

            --> 实现子系统的功能，处理外观类指派的任务，注意子系统类不含有外观类的引用

    优点：

        --> 降低客户端与子系统间的耦合度；
        --> 对客户屏蔽子系统组件，从而能简化接口，减少客户端处理的对象数目；
        --> 一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象

    缺点：

        --> 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了”开闭原则”。
        --> 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。